# Duration Encoding -------------------------------------------------------

#' Internal functions providing information about sedentary bout patterns
#'
#' These functions are invoked in the \code{\link{sb_bout_summary}} wrapper
#'
#' @param d one-row data frame with bout information
#' @param bouts data frame with information for each bout, based on
#'   \code{PAutilities::index_runs}
#' @param total_length the number of rows in the original data.
#'
#' @note There is some potential for confusion, because \code{a} is equivalent
#'   to the \code{d} argument of \code{\link{sb_bout_summary}}, while \code{d}
#'   is a one-row data frame generated by the initial operations of
#'   \code{\link{sb_bout_summary}}. This would be avoidable with revision, but
#'   there is not much incentive for doing so because this is an internal
#'   function.
#'
#' @keywords internal
#' @name SB_bouts_internal
sb_range_bouts <- function(d, bouts) {
  data.frame(
    d,
    sb_0_14 = sum(ifelse(
      bouts$lengths < 15, bouts$lengths, 0
    )) / d$n_days / 60,
    sb_15_29 = sum(ifelse(
      bouts$lengths >= 15 & bouts$lengths < 30, bouts$lengths, 0
    )) / d$n_days / 60,
    sb_30_Inf = sum(ifelse(
      bouts$lengths >= 30, bouts$lengths, 0
    )) / d$n_days / 60
  ) %T>%
  {stopifnot(isTRUE(all.equal(
    sum(rev(.)[ ,1:3]), sum(bouts$lengths) / d$n_days / 60,
    scale = 1, tolerance = 1/60/10
  )))}
}

# Duration Summarizing ----------------------------------------------------

#' @keywords internal
#' @name SB_bouts_internal
usual_bout_duration <- function(d, bouts) {

  df <-
    table(bouts$lengths) %>%
    data.frame(stringsAsFactors = FALSE) %>%
    stats::setNames(., gsub("^Var1$", "l", names(.))) %>%
    within({
      l = as.numeric(as.character(l))
      cumprop = 0
      prop = 0
      tot.l = l * Freq
      total_time = sum(tot.l)
      prop = tot.l/total_time
      total_time = NULL
      cumprop = cumsum(prop)
    }) %T>%
    {stopifnot(identical(order(.$l), seq(nrow(.))))}

  empirical <-
    abs(df$cumprop - 0.5) %>%
    which.min(.) %>%
    df$l[.]

  predicted <- try(stats::nls(
    cumprop ~ l^n/(l^n+W50^n),
    data = df,
    start = c(n=1,W50=empirical)
  ), TRUE)

  if (inherits(predicted, "try-error")) {
    warning(
      "Error fitting model for predicted usual bout",
      " duration -- returning NA", call. = FALSE
    )
    predicted <- NA
  } else {
    predicted %<>%
      stats::coef(.) %>%
      .["W50"] %>%
      unname(.)
  }

  data.frame(d, ubd_empirical = empirical, ubd_predicted = predicted)

}

# SB Breaks ---------------------------------------------------------------

#' @keywords internal
#' @name SB_bouts_internal
fragmentation_index <- function(d, total_length, bouts) {
  bouts %>%
  within({
    `break` = ifelse(end_index == total_length, 0, 1)
  }) %>%
  {sum(.$`break`) / sum(.$lengths) * 60} %>%
  data.frame(d, fragmentation_index = .)
}

# Complex Metrics ---------------------------------------------------------

#' @keywords internal
#' @name SB_bouts_internal
gini <- function(d, bouts) {
  data.frame(d, gini = DescTools::Gini(bouts$lengths))
}

#' @keywords internal
#' @name SB_bouts_internal
alpha <- function(d, bouts) {
  bouts$lengths %>%
  sapply(., function(xi, xm) log(xi/xm), xm = min(.)) %>%
  sum(.) %>%
  {data.frame(
    alpha = 1 + nrow(bouts)/.
  )} %>%
  within({
    alpha_se = (alpha - 1) / sqrt(nrow(bouts))
  }) %>%
  data.frame(d, .)
}
